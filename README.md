# everytime_timeTable_subject
20200854 윤민혁 / 소프트웨어 공학 / 일상 속 소프트웨어 사용 사례를 주제로 시퀀스 다이어그램을 작성하고, 이를 기반으로 샘플 코드를 구현
- 에브리타임 시간표 확인 및 강의 정보 확인 사용 사례 시퀀스 다이어그램/코드 구현

### 이 사례를 선택한 이유
일상 속 소프트웨어 사용 사례를 떠올려보니, 주로 **배달앱** 또는 **에브리타임 앱의 시간표 기능**을 많이 사용한다는 것을 알게되었다. 
두 사례 중에 고민하던 끝에, 배달 앱보다는 **에브리타임 시간표 확인이나 강의정보를 조회하는**경우가 더 익숙하고 구체적인 흐름을 표현하기 적합하다고 느껴 이를 주제로 선택하게 되었다.


<br><br>

## 1.시퀀스 다이어그램: 시퀀스 다이어그램으로 모델링 – Mermaid.live 활용
#### 1.에브리타임 시간표&강의정보 확인 시퀀스 다이어그램
![에브리타임_시퀀스다이어그램](https://github.com/user-attachments/assets/4cea5b15-0dba-46a3-9d51-5eb9db0f2e93)

> 시퀀스 다이어그램의 각 단계와 동작 내용은 다음과 같음.
1.	사용자(User) =>	ID/PW 입력 (로그인 시도)
2.	에브리타임 애플리케이션 =>	로그인 정보 확인 후 로그인 성공 여부에 따라 메시지 출력
4.	사용자 =>	시간표 조회 요청
5.	에브리타임 애플리케이션 =>	시간표에게 사용자의 시간표 요청
6.	시간표 =>	요청에 대한 시간표 반환
7.	에브리타임 애플리케이션 =>	사용자에게 시간표 출력
8.	사용자 =>	시간표 중 특정 강의 정보 선택
9.	에브리타임 애플리케이션 =>	강의 정보 DB에 사용자가 선택한 강의 정보 요청
10.	강의 정보 DB =>	요청한 강의 정보 반환
11.	에브리타임 애플리케이션 =>	사용자에게 강의의 상세정보 출력
12.	사용자 =>	강의 정보를 더 볼 것인지에 대한 응답 (y/n) 입력
13.	에브리타임 애플리케이션 =>	y: 다시 시간표를 사용자에게 보여줌 / n: 애플리케이션 종료

<br><br>

## 3. 샘플 코드의 모듈 평가 결과 간략히 작성 (샘플 코드의 응집도, 결합도 평가)

#### 3-1. 응집도 평가
  
  
**사용자 모듈** : <u>사용자 입력과 선택을 담당</u>하며, 그에 관련된 데이터를 교환하므로 → 적절히 높은 응집도를 가짐, *교환적 응집도*
  
**에브리타임 애플리케이션 모듈** : <u>로그인, 시간표 요청, 강의 선택 처리</u> 등 앱 흐름 담당 → 높은 응집도를 가짐, *순차적 응집도*
  
**시간표 모듈** : <u>시간표 데이터 제공만</u>을 수행 → 매우 높은 응집도를 가짐, *기능적 응집도*
  
**강의 정보 DB 모듈** : <u>강의 정보만</u>을 제공 → 매우 높은 응집도를 가짐, *기능적 응집도*

  
> 즉, 각 모듈은 명확한 책임을 가지고, 불필요한 기능이 섞여 있지 않아 전반적으로 응집도가 높다고 평가한다.


#### 3-2. 결합도 평가

**사용자 <-> 에브리타임 앱** : <u>사용자의 입력(ID, PW, 강의번호)만</u> 전달 됨 → 결합도가 낮음, *자료 결합도*
  
**에브리타임 앱 <-> 시간표** : <u>시간표 요청 시 단순 값(강의 번호, 수업명)만</u> 전달 됨 → 결합도가 낮음, *자료 결합도*
  
**에브리타임 앱 <-> 강의 정보 DB** : <u>기본 데이터(교수님 성함, 수업명, 수업시각, 강의실정보)만 전달 됨</u> → 결합도가 낮음, *자료 결합도*
    
> 모든 모듈간 연결은 단순하고 필요한 정보만 주고받는 구조이기 때문에, 전부 결합도가 낮다고 평가한다.


#### 3-3. 평가 결론
  
> **응집도가 높고 결합도가 낮은 구조**이므로, 유지보수 및 확장에 유리한 구조로 구현하였다.
